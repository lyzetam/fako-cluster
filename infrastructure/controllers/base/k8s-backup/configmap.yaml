# infrastructure/controllers/base/k8s-backup/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: backup-scripts
  namespace: backup-system
data:
  backup.sh: |
    #!/bin/bash
    set -e
    
    BACKUP_DIR="/backups"
    DATE=$(date +%Y%m%d-%H%M%S)
    BACKUP_PATH="$BACKUP_DIR/$DATE"
    
    echo "Starting Kubernetes backup - $DATE"
    mkdir -p "$BACKUP_PATH"
    
    # Namespaces to backup (modify as needed)
    NAMESPACES=${NAMESPACES:-"default flux-system"}
    
    # Backup all resources in specified namespaces
    for ns in $NAMESPACES; do
      echo "Backing up namespace: $ns"
      mkdir -p "$BACKUP_PATH/$ns"
      
      # Get all resources in namespace
      kubectl get all,cm,secret,pvc,ingress,networkpolicy -n "$ns" -o yaml > "$BACKUP_PATH/$ns/resources.yaml" 2>/dev/null || true
      
      # Backup specific resource types separately for easier restore
      for resource in deployment statefulset daemonset service configmap secret persistentvolumeclaim ingress; do
        kubectl get "$resource" -n "$ns" -o yaml > "$BACKUP_PATH/$ns/${resource}.yaml" 2>/dev/null || true
      done
    done
    
    # Backup cluster-wide resources
    echo "Backing up cluster resources"
    mkdir -p "$BACKUP_PATH/cluster"
    kubectl get nodes,pv,storageclass,namespace -o yaml > "$BACKUP_PATH/cluster/cluster-resources.yaml" 2>/dev/null || true
    
    # Create backup metadata
    cat > "$BACKUP_PATH/backup-info.txt" <<EOF
    Backup Date: $DATE
    Namespaces: $NAMESPACES
    Cluster: $(kubectl config current-context)
    Nodes: $(kubectl get nodes -o name | wc -l)
    EOF
    
    # Cleanup old backups (keep last 30 days)
    find "$BACKUP_DIR" -maxdepth 1 -type d -mtime +30 -exec rm -rf {} \; 2>/dev/null || true
    
    echo "Backup completed: $BACKUP_PATH"
    ls -la "$BACKUP_PATH"

  restore.sh: |
    #!/bin/bash
    # Simple restore script
    set -e
    
    if [ -z "$1" ]; then
      echo "Usage: $0 <backup-date>"
      echo "Available backups:"
      ls -1 /backups/
      exit 1
    fi
    
    BACKUP_PATH="/backups/$1"
    
    if [ ! -d "$BACKUP_PATH" ]; then
      echo "Backup not found: $BACKUP_PATH"
      exit 1
    fi
    
    echo "Restoring from: $BACKUP_PATH"
    
    # Restore namespaces first
    kubectl apply -f "$BACKUP_PATH/cluster/cluster-resources.yaml" --dry-run=client || true
    
    # Restore each namespace
    for ns_dir in "$BACKUP_PATH"/*; do
      if [ -d "$ns_dir" ] && [ "$(basename "$ns_dir")" != "cluster" ]; then
        ns=$(basename "$ns_dir")
        echo "Restoring namespace: $ns"
        
        # Create namespace if it doesn't exist
        kubectl create namespace "$ns" --dry-run=client -o yaml | kubectl apply -f -
        
        # Apply resources
        for yaml in "$ns_dir"/*.yaml; do
          echo "Applying: $yaml"
          kubectl apply -f "$yaml" --dry-run=client || true
        done
      fi
    done
    
    echo "Restore dry-run completed. Remove --dry-run=client to actually restore."
