apiVersion: v1
kind: ConfigMap
metadata:
  name: voice-ingest-server-script
  namespace: voice-ingest
data:
  server.py: |
    #!/usr/bin/env python3
    """
    Voice Ingest Server
    Receives audio uploads, transcribes via WhisperX, summarizes via Ollama,
    and saves to Obsidian.

    Uses only Python standard library - no pip install needed.
    """

    import os
    import json
    import logging
    import ssl
    import urllib.request
    import urllib.parse
    from http.server import HTTPServer, BaseHTTPRequestHandler
    from pathlib import Path
    from datetime import datetime
    import hashlib
    import re

    # Configuration from environment
    WHISPERX_URL = os.getenv("WHISPERX_URL", "http://whisperx-api.whisperx.svc.cluster.local:8000")
    OLLAMA_URL = os.getenv("OLLAMA_URL", "http://ollama-gpu.ollama.svc.cluster.local:11434")
    OLLAMA_MODEL = os.getenv("OLLAMA_MODEL", "llama3.2:3b")
    OBSIDIAN_API_URL = os.getenv("OBSIDIAN_API_URL", "")
    OBSIDIAN_API_KEY = os.getenv("OBSIDIAN_API_KEY", "")
    OBSIDIAN_FOLDER = os.getenv("OBSIDIAN_FOLDER", "Voice-Journals")
    API_TOKEN = os.getenv("API_TOKEN", "change-me-in-production")
    PORT = int(os.getenv("PORT", "8080"))
    UPLOAD_DIR = Path(os.getenv("UPLOAD_DIR", "/data/uploads"))
    PROCESSED_DIR = Path(os.getenv("PROCESSED_DIR", "/data/processed"))
    STATE_DIR = Path(os.getenv("STATE_DIR", "/data/state"))

    # Logging
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(levelname)s - %(message)s'
    )
    logger = logging.getLogger(__name__)

    # SSL context for self-signed certs (Obsidian)
    SSL_CONTEXT = ssl.create_default_context()
    SSL_CONTEXT.check_hostname = False
    SSL_CONTEXT.verify_mode = ssl.CERT_NONE

    # Summary prompt
    SUMMARY_PROMPT = """You are summarizing a voice recording transcript. The transcript may include speaker labels (SPEAKER_00, SPEAKER_01, etc.) from automatic speaker diarization.

    Please provide:
    1. **Summary**: A 2-3 paragraph overview of what was discussed
    2. **Key Topics**: Main subjects covered (bullet list)
    3. **Action Items**: Any tasks or follow-ups mentioned
    4. **Speakers**: If multiple speakers detected, note how many and their apparent roles if discernible

    Be concise but comprehensive. Focus on extracting useful information."""


    def ensure_dirs():
        """Create necessary directories."""
        UPLOAD_DIR.mkdir(parents=True, exist_ok=True)
        PROCESSED_DIR.mkdir(parents=True, exist_ok=True)
        STATE_DIR.mkdir(parents=True, exist_ok=True)


    def transcribe_audio(filepath: Path) -> dict:
        """Send audio to WhisperX for transcription + diarization."""
        logger.info(f"Transcribing: {filepath.name}")

        # Read file content
        with open(filepath, 'rb') as f:
            file_content = f.read()

        # Build multipart form data manually (no requests library)
        boundary = '----WebKitFormBoundary' + hashlib.md5(str(datetime.now()).encode()).hexdigest()[:16]

        body = []

        # Add file field
        body.append(f'--{boundary}'.encode())
        body.append(f'Content-Disposition: form-data; name="file"; filename="{filepath.name}"'.encode())
        body.append(b'Content-Type: audio/wav')
        body.append(b'')
        body.append(file_content)

        # Add diarize field
        body.append(f'--{boundary}'.encode())
        body.append(b'Content-Disposition: form-data; name="diarize"')
        body.append(b'')
        body.append(b'true')

        # Add align field
        body.append(f'--{boundary}'.encode())
        body.append(b'Content-Disposition: form-data; name="align"')
        body.append(b'')
        body.append(b'true')

        # Close boundary
        body.append(f'--{boundary}--'.encode())
        body.append(b'')

        body_bytes = b'\r\n'.join(body)

        headers = {
            'Content-Type': f'multipart/form-data; boundary={boundary}',
            'Content-Length': str(len(body_bytes))
        }

        req = urllib.request.Request(
            f"{WHISPERX_URL}/transcribe",
            data=body_bytes,
            headers=headers,
            method='POST'
        )

        try:
            with urllib.request.urlopen(req, timeout=600) as response:
                result = json.loads(response.read().decode('utf-8'))
                logger.info(f"Transcription complete: {len(result.get('text', ''))} chars")
                return result
        except Exception as e:
            logger.error(f"WhisperX error: {e}")
            raise


    def format_transcript_with_speakers(result: dict) -> str:
        """Format transcript with speaker labels if available."""
        segments = result.get('segments', [])

        if not segments:
            return result.get('text', '')

        # Check if we have speaker info
        has_speakers = any('speaker' in seg for seg in segments)

        if not has_speakers:
            return result.get('text', '')

        # Format with speaker labels
        lines = []
        current_speaker = None
        current_text = []

        for seg in segments:
            speaker = seg.get('speaker', 'UNKNOWN')
            text = seg.get('text', '').strip()

            if speaker != current_speaker:
                if current_text:
                    lines.append(f"**{current_speaker}**: {' '.join(current_text)}")
                current_speaker = speaker
                current_text = [text] if text else []
            else:
                if text:
                    current_text.append(text)

        # Don't forget the last speaker
        if current_text:
            lines.append(f"**{current_speaker}**: {' '.join(current_text)}")

        return '\n\n'.join(lines)


    def summarize_transcript(transcript_text: str) -> str:
        """Send transcript to Ollama for summarization."""
        logger.info(f"Summarizing transcript ({len(transcript_text)} chars)")

        # Truncate if too long (context window limits)
        max_chars = 25000
        if len(transcript_text) > max_chars:
            logger.warning(f"Truncating from {len(transcript_text)} to {max_chars}")
            transcript_text = transcript_text[:max_chars] + "\n\n[...truncated...]"

        payload = {
            "model": OLLAMA_MODEL,
            "messages": [
                {"role": "system", "content": SUMMARY_PROMPT},
                {"role": "user", "content": f"Please summarize this transcript:\n\n{transcript_text}"}
            ],
            "stream": False,
            "options": {
                "temperature": 0.3
            }
        }

        data = json.dumps(payload).encode('utf-8')
        headers = {
            'Content-Type': 'application/json',
            'Content-Length': str(len(data))
        }

        req = urllib.request.Request(
            f"{OLLAMA_URL}/api/chat",
            data=data,
            headers=headers,
            method='POST'
        )

        try:
            with urllib.request.urlopen(req, timeout=300) as response:
                result = json.loads(response.read().decode('utf-8'))
                summary = result.get('message', {}).get('content', '')
                logger.info(f"Summary generated: {len(summary)} chars")
                return summary
        except Exception as e:
            logger.error(f"Ollama error: {e}")
            return f"*Summary generation failed: {e}*"


    def post_to_obsidian(filename: str, content: str) -> bool:
        """Post markdown content to Obsidian vault."""
        if not OBSIDIAN_API_URL or not OBSIDIAN_API_KEY:
            logger.warning("Obsidian not configured, skipping")
            return False

        url = f"{OBSIDIAN_API_URL}/vault/{OBSIDIAN_FOLDER}/{filename}"
        headers = {
            'Authorization': f'Bearer {OBSIDIAN_API_KEY}',
            'Content-Type': 'text/markdown'
        }

        req = urllib.request.Request(
            url,
            data=content.encode('utf-8'),
            headers=headers,
            method='PUT'
        )

        try:
            ctx = SSL_CONTEXT if OBSIDIAN_API_URL.startswith('https') else None
            with urllib.request.urlopen(req, context=ctx, timeout=30) as response:
                logger.info(f"Posted to Obsidian: {filename}")
                return response.status in (200, 201, 204)
        except Exception as e:
            logger.error(f"Obsidian error: {e}")
            return False


    def process_audio(filepath: Path) -> dict:
        """Full processing pipeline for an audio file."""
        logger.info(f"Processing: {filepath.name}")

        # 1. Transcribe with WhisperX
        transcript_result = transcribe_audio(filepath)

        # 2. Format transcript with speaker labels
        formatted_transcript = format_transcript_with_speakers(transcript_result)

        # 3. Summarize with Ollama
        summary = summarize_transcript(formatted_transcript)

        # 4. Create markdown document
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        date_str = datetime.now().strftime("%Y-%m-%d")

        # Extract metadata
        duration = transcript_result.get('duration', 0)
        language = transcript_result.get('language', 'en')
        segments = transcript_result.get('segments', [])
        speakers = set(seg.get('speaker', 'UNKNOWN') for seg in segments if 'speaker' in seg)

        markdown = "# Voice Recording - " + filepath.stem + "\n\n"
        markdown += "Captured: " + timestamp + "\n"
        markdown += "Duration: " + f"{duration:.1f}s" + " | Language: " + language
        markdown += " | Speakers: " + (str(len(speakers)) if speakers else "N/A") + "\n\n"
        markdown += "---\n\n"
        markdown += "## AI Summary\n\n"
        markdown += summary + "\n\n"
        markdown += "---\n\n"
        markdown += "## Full Transcript\n\n"
        markdown += formatted_transcript + "\n\n"
        markdown += "---\n\n"
        markdown += "Processed by voice-ingest pipeline\n"
        markdown += "Tags: #voice-recording #transcript #auto-generated\n"

        # 5. Save to Obsidian
        md_filename = f"{date_str}-{filepath.stem}.md"
        obsidian_success = post_to_obsidian(md_filename, markdown)

        # 6. Save processed JSON
        output_file = PROCESSED_DIR / f"{filepath.stem}.json"
        with open(output_file, 'w') as f:
            json.dump({
                "source_file": filepath.name,
                "processed_at": timestamp,
                "transcript": transcript_result,
                "summary": summary,
                "obsidian_saved": obsidian_success
            }, f, indent=2)

        # 7. Move original to processed
        processed_audio = PROCESSED_DIR / filepath.name
        filepath.rename(processed_audio)

        return {
            "status": "success",
            "file": filepath.name,
            "transcript_chars": len(formatted_transcript),
            "summary_chars": len(summary),
            "obsidian_saved": obsidian_success,
            "speakers_detected": len(speakers) if speakers else 0
        }


    class VoiceIngestHandler(BaseHTTPRequestHandler):
        """HTTP request handler for voice ingest API."""

        def send_json(self, status: int, data: dict):
            """Send JSON response."""
            self.send_response(status)
            self.send_header('Content-Type', 'application/json')
            self.end_headers()
            self.wfile.write(json.dumps(data).encode())

        def check_auth(self) -> bool:
            """Verify API token."""
            auth = self.headers.get('Authorization', '')
            if auth.startswith('Bearer '):
                token = auth[7:]
                return token == API_TOKEN
            return False

        def do_GET(self):
            """Handle GET requests."""
            if self.path == '/health':
                self.send_json(200, {"status": "healthy"})
            elif self.path == '/':
                self.send_json(200, {
                    "service": "voice-ingest",
                    "endpoints": {
                        "GET /health": "Health check",
                        "POST /upload": "Upload audio file",
                        "GET /status": "Processing status"
                    }
                })
            elif self.path == '/status':
                if not self.check_auth():
                    self.send_json(401, {"error": "Unauthorized"})
                    return

                uploads = list(UPLOAD_DIR.glob('*.wav')) + list(UPLOAD_DIR.glob('*.mp3'))
                processed = list(PROCESSED_DIR.glob('*.json'))

                self.send_json(200, {
                    "pending_uploads": len(uploads),
                    "processed_files": len(processed),
                    "upload_dir": str(UPLOAD_DIR),
                    "processed_dir": str(PROCESSED_DIR)
                })
            else:
                self.send_json(404, {"error": "Not found"})

        def do_POST(self):
            """Handle POST requests."""
            if self.path == '/upload':
                if not self.check_auth():
                    self.send_json(401, {"error": "Unauthorized"})
                    return

                content_length = int(self.headers.get('Content-Length', 0))
                if content_length == 0:
                    self.send_json(400, {"error": "No content"})
                    return

                # Get filename from header or generate one
                filename = self.headers.get('X-Filename', f"recording_{datetime.now().strftime('%Y%m%d_%H%M%S')}.wav")

                # Read and save file
                file_data = self.rfile.read(content_length)
                filepath = UPLOAD_DIR / filename

                with open(filepath, 'wb') as f:
                    f.write(file_data)

                logger.info(f"Received upload: {filename} ({len(file_data)} bytes)")

                # Process immediately
                try:
                    result = process_audio(filepath)
                    self.send_json(200, result)
                except Exception as e:
                    logger.error(f"Processing error: {e}")
                    self.send_json(500, {"error": str(e), "file": filename})

            elif self.path == '/process':
                # Process all pending uploads
                if not self.check_auth():
                    self.send_json(401, {"error": "Unauthorized"})
                    return

                uploads = list(UPLOAD_DIR.glob('*.wav')) + list(UPLOAD_DIR.glob('*.mp3'))
                results = []

                for filepath in uploads:
                    try:
                        result = process_audio(filepath)
                        results.append(result)
                    except Exception as e:
                        results.append({"file": filepath.name, "status": "error", "error": str(e)})

                self.send_json(200, {"processed": len(results), "results": results})
            else:
                self.send_json(404, {"error": "Not found"})

        def log_message(self, format, *args):
            """Use Python logging instead of stderr."""
            logger.info("%s - %s" % (self.client_address[0], format % args))


    def main():
        """Start the server."""
        ensure_dirs()

        server = HTTPServer(('0.0.0.0', PORT), VoiceIngestHandler)
        logger.info(f"Voice Ingest Server starting on port {PORT}")
        logger.info(f"WhisperX: {WHISPERX_URL}")
        logger.info(f"Ollama: {OLLAMA_URL} ({OLLAMA_MODEL})")
        logger.info(f"Obsidian: {'configured' if OBSIDIAN_API_URL else 'not configured'}")

        try:
            server.serve_forever()
        except KeyboardInterrupt:
            logger.info("Shutting down")
            server.shutdown()


    if __name__ == '__main__':
        main()
