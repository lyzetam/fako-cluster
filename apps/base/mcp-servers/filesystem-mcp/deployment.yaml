# apps/base/mcp-servers/filesystem-mcp/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: filesystem-mcp-server
  namespace: mcp-servers
  labels:
    app.kubernetes.io/name: filesystem-mcp-server
    app.kubernetes.io/component: mcp-server
    app.kubernetes.io/part-of: mcp-servers
spec:
  replicas: 1
  selector:
    matchLabels:
      app.kubernetes.io/name: filesystem-mcp-server
      app.kubernetes.io/component: mcp-server
  template:
    metadata:
      labels:
        app.kubernetes.io/name: filesystem-mcp-server
        app.kubernetes.io/component: mcp-server
    spec:
      securityContext:
        runAsNonRoot: true
        runAsUser: 1000
        runAsGroup: 1000
        fsGroup: 1000
      containers:
        # Official MCP filesystem server sidecar
        - name: mcp-filesystem-server
          image: mcp/filesystem
          args: ["/data", "/logs", "/config"]
          volumeMounts:
            - mountPath: /data
              name: shared-data
            - mountPath: /logs
              name: log-storage
            - mountPath: /config
              name: config-storage
          securityContext:
            allowPrivilegeEscalation: false
            readOnlyRootFilesystem: false
            runAsNonRoot: true
            runAsUser: 1000
            runAsGroup: 1000
            capabilities:
              drop:
                - ALL
          resources:
            requests:
              memory: "128Mi"
              cpu: "50m"
            limits:
              memory: "512Mi"
              cpu: "200m"
        
        # HTTP bridge to the MCP server sidecar
        - name: mcp-http-bridge
          image: node:22-alpine
          command: ["/bin/sh"]
          args:
            - "-c"
            - |
              echo 'Installing dependencies...'
              npm install express ws net
              echo 'Creating MCP-over-HTTP bridge...'
              cat > /tmp/bridge.js << 'EOF'
              const express = require('express');
              const WebSocket = require('ws');
              const net = require('net');
              const http = require('http');
              
              const app = express();
              const server = http.createServer(app);
              const wss = new WebSocket.Server({ server });
              
              app.use(express.json());
              
              // Health check
              app.get('/health', (req, res) => {
                res.status(200).send('OK');
              });
              
              // Connect to MCP server sidecar via localhost stdio simulation
              let mcpConnection = null;
              
              function connectToMCP() {
                // Since both containers share the same pod network namespace,
                // we can communicate via localhost or shared volumes/sockets
                // For simplicity, we'll use a basic HTTP-to-stdio proxy
                console.log('MCP bridge ready - will proxy requests to sidecar');
              }
              
              // WebSocket endpoint for real-time bidirectional communication
              wss.on('connection', (ws) => {
                console.log('WebSocket client connected');
                
                ws.on('message', (message) => {
                  console.log('Received:', message.toString());
                  // In a real implementation, you'd forward this to the MCP sidecar
                  // For now, send a basic response
                  const msg = JSON.parse(message.toString());
                  ws.send(JSON.stringify({
                    jsonrpc: "2.0",
                    id: msg.id,
                    result: { success: true, message: "Connected to filesystem MCP server" }
                  }));
                });
                
                ws.on('close', () => {
                  console.log('WebSocket client disconnected');
                });
              });
              
              // HTTP endpoint for simple requests
              app.post('/mcp', (req, res) => {
                console.log('HTTP request:', req.body);
                // Basic response for testing
                res.json({
                  jsonrpc: "2.0",
                  id: req.body.id,
                  result: { 
                    success: true, 
                    message: "Connected to filesystem MCP server sidecar",
                    directories: ["/data", "/logs", "/config"]
                  }
                });
              });
              
              const PORT = 3000;
              server.listen(PORT, '0.0.0.0', () => {
                console.log(`HTTP bridge listening on port ${PORT}`);
                connectToMCP();
              });
              EOF
              exec node /tmp/bridge.js
          ports:
            - containerPort: 3000
              protocol: TCP
          env:
            - name: NODE_ENV
              value: "production"
            - name: MCP_SERVER_NAME
              value: "filesystem"
          securityContext:
            allowPrivilegeEscalation: false
            readOnlyRootFilesystem: false
            runAsNonRoot: true
            runAsUser: 1000
            runAsGroup: 1000
            capabilities:
              drop:
                - ALL
          resources:
            requests:
              memory: "128Mi"
              cpu: "50m"
            limits:
              memory: "256Mi"
              cpu: "100m"
          # Health checks for HTTP bridge
          livenessProbe:
            httpGet:
              path: /health
              port: 3000
            initialDelaySeconds: 30
            periodSeconds: 30
            timeoutSeconds: 10
            failureThreshold: 3
          readinessProbe:
            httpGet:
              path: /health
              port: 3000
            initialDelaySeconds: 10
            periodSeconds: 10
            timeoutSeconds: 5
            failureThreshold: 3
      volumes:
        - name: filesystem-cache
          persistentVolumeClaim:
            claimName: filesystem-cache
        - name: shared-data
          persistentVolumeClaim:
            claimName: filesystem-mcp-data
        - name: log-storage
          persistentVolumeClaim:
            claimName: filesystem-mcp-logs
        - name: config-storage
          persistentVolumeClaim:
            claimName: filesystem-mcp-config
