# apps/base/mcp-servers/filesystem-mcp/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: filesystem-mcp-server
  namespace: mcp-servers
  labels:
    app.kubernetes.io/name: filesystem-mcp-server
    app.kubernetes.io/component: mcp-server
    app.kubernetes.io/part-of: mcp-servers
spec:
  replicas: 1
  selector:
    matchLabels:
      app.kubernetes.io/name: filesystem-mcp-server
      app.kubernetes.io/component: mcp-server
  template:
    metadata:
      labels:
        app.kubernetes.io/name: filesystem-mcp-server
        app.kubernetes.io/component: mcp-server
    spec:
      securityContext:
        runAsNonRoot: true
        runAsUser: 1000
        runAsGroup: 1000
        fsGroup: 1000
      containers:
        - name: filesystem-mcp-server
          image: node:22-alpine
          # Install and run the filesystem MCP server with HTTP transport wrapper
          command: ["/bin/sh"]
          args: 
            - "-c"
            - |
              echo 'Starting filesystem MCP server setup...'
              # Create a simple HTTP-to-stdio bridge for the MCP server
              cat > /tmp/mcp_http_bridge.js << 'EOF'
              const http = require('http');
              const { spawn } = require('child_process');
              
              const server = http.createServer((req, res) => {
                if (req.method === 'GET' && req.url === '/health') {
                  res.writeHead(200, { 'Content-Type': 'text/plain' });
                  res.end('OK');
                  return;
                }
                
                if (req.method !== 'POST') {
                  res.writeHead(405, { 'Content-Type': 'text/plain' });
                  res.end('Method Not Allowed');
                  return;
                }
                
                let body = '';
                req.on('data', chunk => {
                  body += chunk.toString();
                });
                
                req.on('end', () => {
                  // Spawn the MCP server with the mounted directories
                  const mcp = spawn('npx', ['-y', '@modelcontextprotocol/server-filesystem', '/data', '/logs', '/config'], {
                    stdio: ['pipe', 'pipe', 'pipe']
                  });
                  
                  let output = '';
                  let errorOutput = '';
                  
                  mcp.stdout.on('data', (data) => {
                    output += data.toString();
                  });
                  
                  mcp.stderr.on('data', (data) => {
                    errorOutput += data.toString();
                  });
                  
                  mcp.on('close', (code) => {
                    if (code !== 0) {
                      console.error('MCP server exited with code:', code);
                      console.error('Error output:', errorOutput);
                    }
                    res.writeHead(200, { 'Content-Type': 'application/json' });
                    res.end(output);
                  });
                  
                  // Send the request to the MCP server
                  mcp.stdin.write(body);
                  mcp.stdin.end();
                });
              });
              
              const PORT = 3000;
              server.listen(PORT, '0.0.0.0', () => {
                console.log(`MCP HTTP Bridge listening on port ${PORT}...`);
              });
              EOF
              # Create readiness file for health checks
              echo 'ready' > /tmp/mcp-server-ready || echo 'Cannot create readiness file'
              echo 'Starting MCP HTTP bridge on port 3000...'
              # Start the HTTP bridge
              exec node /tmp/mcp_http_bridge.js
          ports:
            - containerPort: 3000
              protocol: TCP
          env:
            - name: PORT
              value: "3000"
            - name: NODE_ENV
              value: "production"
            - name: MCP_SERVER_NAME
              value: "filesystem"
          volumeMounts:
            - name: filesystem-cache
              mountPath: /app/cache
            - mountPath: /data
              name: shared-data
            - mountPath: /logs
              name: log-storage
            - mountPath: /config
              name: config-storage
          securityContext:
            allowPrivilegeEscalation: false
            readOnlyRootFilesystem: false
            runAsNonRoot: true
            runAsUser: 1000
            runAsGroup: 1000
            capabilities:
              drop:
                - ALL
          resources:
            requests:
              memory: "256Mi"
              cpu: "100m"
            limits:
              memory: "1Gi"
              cpu: "500m"
          # Health checks - use simple file-based approach since ps/grep not available in minimal image
          livenessProbe:
            exec:
              command:
                - /bin/sh
                - -c
                - "test -f /tmp/mcp-server-ready"
            initialDelaySeconds: 60
            periodSeconds: 30
            timeoutSeconds: 10
            failureThreshold: 3
          readinessProbe:
            exec:
              command:
                - /bin/sh
                - -c
                - "test -f /tmp/mcp-server-ready"
            initialDelaySeconds: 30
            periodSeconds: 10
            timeoutSeconds: 5
            failureThreshold: 3
      volumes:
        - name: filesystem-cache
          persistentVolumeClaim:
            claimName: filesystem-cache
        - name: shared-data
          persistentVolumeClaim:
            claimName: filesystem-mcp-data
        - name: log-storage
          persistentVolumeClaim:
            claimName: filesystem-mcp-logs
        - name: config-storage
          persistentVolumeClaim:
            claimName: filesystem-mcp-config
