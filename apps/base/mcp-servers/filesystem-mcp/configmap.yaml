# apps/base/mcp-servers/filesystem-mcp/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: filesystem-mcp-source
  namespace: mcp-servers
  labels:
    app.kubernetes.io/name: filesystem-mcp-server
    app.kubernetes.io/component: mcp-server
    app.kubernetes.io/part-of: mcp-servers
data:
  package.json: |
    {
      "name": "filesystem-mcp-server",
      "version": "1.0.0",
      "description": "Filesystem MCP server for secure file operations",
      "main": "index.js",
      "scripts": {
        "start": "node index.js",
        "dev": "node index.js"
      },
      "dependencies": {
        "@modelcontextprotocol/sdk": "^1.0.0",
        "fs-extra": "^11.2.0",
        "mime-types": "^2.1.35"
      },
      "engines": {
        "node": ">=18.0.0"
      },
      "keywords": ["mcp", "filesystem", "server"],
      "author": "fako-cluster",
      "license": "MIT"
    }
  
  index.js: |
    #!/usr/bin/env node

    const { Server } = require('@modelcontextprotocol/sdk/server/index.js');
    const { StdioServerTransport } = require('@modelcontextprotocol/sdk/server/stdio.js');
    const { SSEServerTransport } = require('@modelcontextprotocol/sdk/server/sse.js');
    const {
      CallToolRequestSchema,
      ErrorCode,
      ListToolsRequestSchema,
      McpError,
    } = require('@modelcontextprotocol/sdk/types.js');
    const fs = require('fs-extra');
    const path = require('path');
    const mime = require('mime-types');

    // Security configuration - support both command line args and environment variables
    let ALLOWED_DIRECTORIES;
    if (process.argv.length > 2) {
      // Use command line arguments if provided
      ALLOWED_DIRECTORIES = process.argv.slice(2);
    } else {
      // Fall back to environment variable
      ALLOWED_DIRECTORIES = process.env.ALLOWED_DIRECTORIES?.split(',') || ['/projects'];
    }

    const MAX_FILE_SIZE = parseInt(process.env.MAX_FILE_SIZE || '10485760'); // 10MB default

    // Show usage if no directories are configured
    if (!ALLOWED_DIRECTORIES || ALLOWED_DIRECTORIES.length === 0) {
      console.error('Usage: mcp-server-filesystem <allowed-directory> [additional-directories...]');
      console.error('Or set ALLOWED_DIRECTORIES environment variable');
      process.exit(1);
    }

    class FilesystemMCPServer {
      constructor() {
        this.server = new Server(
          {
            name: 'filesystem-mcp-server',
            version: '1.0.0',
          },
          {
            capabilities: {
              tools: {},
            },
          }
        );

        this.setupToolHandlers();
        this.setupErrorHandling();
      }

      isPathAllowed(filePath) {
        const resolvedPath = path.resolve(filePath);
        return ALLOWED_DIRECTORIES.some(allowedDir => {
          const resolvedAllowedDir = path.resolve(allowedDir);
          return resolvedPath.startsWith(resolvedAllowedDir);
        });
      }

      setupToolHandlers() {
        this.server.setRequestHandler(ListToolsRequestSchema, async () => {
          return {
            tools: [
              {
                name: 'read_file',
                description: 'Read the contents of a file',
                inputSchema: {
                  type: 'object',
                  properties: {
                    path: {
                      type: 'string',
                      description: 'Path to the file to read',
                    },
                  },
                  required: ['path'],
                },
              },
              {
                name: 'write_file',
                description: 'Write content to a file',
                inputSchema: {
                  type: 'object',
                  properties: {
                    path: {
                      type: 'string',
                      description: 'Path to the file to write',
                    },
                    content: {
                      type: 'string',
                      description: 'Content to write to the file',
                    },
                  },
                  required: ['path', 'content'],
                },
              },
              {
                name: 'list_directory',
                description: 'List contents of a directory',
                inputSchema: {
                  type: 'object',
                  properties: {
                    path: {
                      type: 'string',
                      description: 'Path to the directory to list',
                    },
                  },
                  required: ['path'],
                },
              },
              {
                name: 'create_directory',
                description: 'Create a directory',
                inputSchema: {
                  type: 'object',
                  properties: {
                    path: {
                      type: 'string',
                      description: 'Path to the directory to create',
                    },
                  },
                  required: ['path'],
                },
              },
              {
                name: 'delete_file',
                description: 'Delete a file',
                inputSchema: {
                  type: 'object',
                  properties: {
                    path: {
                      type: 'string',
                      description: 'Path to the file to delete',
                    },
                  },
                  required: ['path'],
                },
              },
              {
                name: 'file_info',
                description: 'Get information about a file or directory',
                inputSchema: {
                  type: 'object',
                  properties: {
                    path: {
                      type: 'string',
                      description: 'Path to the file or directory',
                    },
                  },
                  required: ['path'],
                },
              },
            ],
          };
        });

        this.server.setRequestHandler(CallToolRequestSchema, async (request) => {
          const { name, arguments: args } = request.params;

          try {
            switch (name) {
              case 'read_file':
                return await this.readFile(args.path);
              case 'write_file':
                return await this.writeFile(args.path, args.content);
              case 'list_directory':
                return await this.listDirectory(args.path);
              case 'create_directory':
                return await this.createDirectory(args.path);
              case 'delete_file':
                return await this.deleteFile(args.path);
              case 'file_info':
                return await this.getFileInfo(args.path);
              default:
                throw new McpError(
                  ErrorCode.MethodNotFound,
                  `Unknown tool: ${name}`
                );
            }
          } catch (error) {
            if (error instanceof McpError) {
              throw error;
            }
            throw new McpError(
              ErrorCode.InternalError,
              `Error executing tool ${name}: ${error instanceof Error ? error.message : String(error)}`
            );
          }
        });
      }

      async readFile(filePath) {
        if (!this.isPathAllowed(filePath)) {
          throw new McpError(ErrorCode.InvalidRequest, `Access denied to path: ${filePath}`);
        }

        try {
          const stats = await fs.stat(filePath);
          if (stats.size > MAX_FILE_SIZE) {
            throw new McpError(ErrorCode.InvalidRequest, `File too large: ${stats.size} bytes`);
          }

          const content = await fs.readFile(filePath, 'utf8');
          const mimeType = mime.lookup(filePath) || 'text/plain';

          return {
            content: [
              {
                type: 'text',
                text: `File: ${filePath}\nMIME Type: ${mimeType}\nSize: ${stats.size} bytes\n\n${content}`,
              },
            ],
          };
        } catch (error) {
          throw new McpError(
            ErrorCode.InternalError,
            `Failed to read file: ${error instanceof Error ? error.message : String(error)}`
          );
        }
      }

      async writeFile(filePath, content) {
        if (!this.isPathAllowed(filePath)) {
          throw new McpError(ErrorCode.InvalidRequest, `Access denied to path: ${filePath}`);
        }

        try {
          await fs.ensureDir(path.dirname(filePath));
          await fs.writeFile(filePath, content, 'utf8');

          return {
            content: [
              {
                type: 'text',
                text: `Successfully wrote ${content.length} characters to ${filePath}`,
              },
            ],
          };
        } catch (error) {
          throw new McpError(
            ErrorCode.InternalError,
            `Failed to write file: ${error instanceof Error ? error.message : String(error)}`
          );
        }
      }

      async listDirectory(dirPath) {
        if (!this.isPathAllowed(dirPath)) {
          throw new McpError(ErrorCode.InvalidRequest, `Access denied to path: ${dirPath}`);
        }

        try {
          const items = await fs.readdir(dirPath);
          const itemDetails = await Promise.all(
            items.map(async (item) => {
              const itemPath = path.join(dirPath, item);
              const stats = await fs.stat(itemPath);
              return {
                name: item,
                type: stats.isDirectory() ? 'directory' : 'file',
                size: stats.size,
                modified: stats.mtime.toISOString(),
              };
            })
          );

          return {
            content: [
              {
                type: 'text',
                text: `Directory listing for ${dirPath}:\n\n${itemDetails
                  .map(
                    (item) =>
                      `${item.type === 'directory' ? 'ðŸ“' : 'ðŸ“„'} ${item.name} (${
                        item.type === 'directory' ? 'dir' : `${item.size} bytes`
                      }) - Modified: ${item.modified}`
                  )
                  .join('\n')}`,
              },
            ],
          };
        } catch (error) {
          throw new McpError(
            ErrorCode.InternalError,
            `Failed to list directory: ${error instanceof Error ? error.message : String(error)}`
          );
        }
      }

      async createDirectory(dirPath) {
        if (!this.isPathAllowed(dirPath)) {
          throw new McpError(ErrorCode.InvalidRequest, `Access denied to path: ${dirPath}`);
        }

        try {
          await fs.ensureDir(dirPath);

          return {
            content: [
              {
                type: 'text',
                text: `Successfully created directory: ${dirPath}`,
              },
            ],
          };
        } catch (error) {
          throw new McpError(
            ErrorCode.InternalError,
            `Failed to create directory: ${error instanceof Error ? error.message : String(error)}`
          );
        }
      }

      async deleteFile(filePath) {
        if (!this.isPathAllowed(filePath)) {
          throw new McpError(ErrorCode.InvalidRequest, `Access denied to path: ${filePath}`);
        }

        try {
          await fs.remove(filePath);

          return {
            content: [
              {
                type: 'text',
                text: `Successfully deleted: ${filePath}`,
              },
            ],
          };
        } catch (error) {
          throw new McpError(
            ErrorCode.InternalError,
            `Failed to delete file: ${error instanceof Error ? error.message : String(error)}`
          );
        }
      }

      async getFileInfo(filePath) {
        if (!this.isPathAllowed(filePath)) {
          throw new McpError(ErrorCode.InvalidRequest, `Access denied to path: ${filePath}`);
        }

        try {
          const stats = await fs.stat(filePath);
          const mimeType = mime.lookup(filePath) || 'unknown';

          return {
            content: [
              {
                type: 'text',
                text: `File Information for ${filePath}:
    Type: ${stats.isDirectory() ? 'Directory' : 'File'}
    Size: ${stats.size} bytes
    MIME Type: ${mimeType}
    Created: ${stats.birthtime.toISOString()}
    Modified: ${stats.mtime.toISOString()}
    Accessed: ${stats.atime.toISOString()}
    Permissions: ${stats.mode.toString(8)}`,
              },
            ],
          };
        } catch (error) {
          throw new McpError(
            ErrorCode.InternalError,
            `Failed to get file info: ${error instanceof Error ? error.message : String(error)}`
          );
        }
      }

      setupErrorHandling() {
        this.server.onerror = (error) => {
          console.error('[MCP Error]', error);
        };

        process.on('SIGINT', async () => {
          await this.server.close();
          process.exit(0);
        });
      }

      async run() {
        // Check if we should use HTTP transport (when PORT is set) or stdio
        const port = process.env.PORT;
        
        if (port) {
          // HTTP transport mode
          const transport = new SSEServerTransport('/mcp', {
            port: parseInt(port),
            host: '0.0.0.0'
          });
          await this.server.connect(transport);
          console.error(`Filesystem MCP server running on HTTP port ${port}`);
        } else {
          // Stdio transport mode (default)
          const transport = new StdioServerTransport();
          await this.server.connect(transport);
          console.error('Filesystem MCP server running on stdio');
        }
      }
    }

    const server = new FilesystemMCPServer();
    server.run().catch(console.error);

  Dockerfile: |
    FROM node:22-alpine AS release

    WORKDIR /app

    COPY package.json /app/package.json
    COPY index.js /app/index.js

    ENV NODE_ENV=production

    RUN npm install --production

    ENTRYPOINT ["node", "/app/index.js"]
